// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: rating.sql

package generated

import (
	"context"
	"time"
)

const getUsersOrderedByRatioForGivenBrand = `-- name: GetUsersOrderedByRatioForGivenBrand :many
SELECT u.id,
       u.first_name,
       u.last_name,
       u.avatar_url,
       COALESCE(r.ratio, 0) AS ratio,
       b.title              AS branch_title,
       b.id                 as branch_id
FROM user_avatar_view u
         LEFT JOIN user_brand_ratio r
         JOIN branches b ON r.branch_id = b.id
              ON u.id = r.user_id
WHERE r.brand_id = $1
  AND r.from_date = $2
  AND r.to_date = $3
ORDER BY r.ratio DESC
OFFSET $4 LIMIT $5
`

type GetUsersOrderedByRatioForGivenBrandParams struct {
	BrandID  int32     `json:"brand_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
	Offset   int32     `json:"offset"`
	Limit    int32     `json:"limit"`
}

type GetUsersOrderedByRatioForGivenBrandRow struct {
	ID          int32   `json:"id"`
	FirstName   string  `json:"first_name"`
	LastName    string  `json:"last_name"`
	AvatarUrl   string  `json:"avatar_url"`
	Ratio       float32 `json:"ratio"`
	BranchTitle string  `json:"branch_title"`
	BranchID    int32   `json:"branch_id"`
}

// SELECT distinct users for given brand ordered by ratio and limited by offset and limit and if there is no any user with ratio let ratio be 0
func (q *Queries) GetUsersOrderedByRatioForGivenBrand(ctx context.Context, arg GetUsersOrderedByRatioForGivenBrandParams) ([]GetUsersOrderedByRatioForGivenBrandRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersOrderedByRatioForGivenBrand,
		arg.BrandID,
		arg.FromDate,
		arg.ToDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersOrderedByRatioForGivenBrandRow
	for rows.Next() {
		var i GetUsersOrderedByRatioForGivenBrandRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.Ratio,
			&i.BranchTitle,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
