// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: sales_manager.sql

package generated

import (
	"context"
	"time"
)

const addSaleOrReplace = `-- name: AddSaleOrReplace :exec
INSERT INTO sales (sales_manager_id, date, amount, sale_type_id)
VALUES ($1, $2, $3, $4) ON CONFLICT (sales_manager_id, date, sale_type_id)
DO
UPDATE SET
    amount = EXCLUDED.amount
`

type AddSaleOrReplaceParams struct {
	SalesManagerID int32     `json:"sales_manager_id"`
	Date           time.Time `json:"date"`
	Amount         int64     `json:"amount"`
	SaleTypeID     int32     `json:"sale_type_id"`
}

// add sale into sales by given sale_type_id, amount, date, sales_manager_id and on conflict replace
func (q *Queries) AddSaleOrReplace(ctx context.Context, arg AddSaleOrReplaceParams) error {
	_, err := q.db.ExecContext(ctx, addSaleOrReplace,
		arg.SalesManagerID,
		arg.Date,
		arg.Amount,
		arg.SaleTypeID,
	)
	return err
}

const getRankedSalesManagers = `-- name: GetRankedSalesManagers :many
WITH sales_summary AS (SELECT sm.id         AS sales_manager_id,
                              SUM(s.amount) AS total_sales_amount,
                              u.first_name  AS first_name,
                              u.last_name   AS last_name,
                              u.avatar_url  AS avatar_url
                       FROM sales s
                                INNER JOIN sales_managers sm ON s.sales_manager_id = sm.id
                                INNER JOIN user_avatar_view u ON sm.user_id = u.id
                       WHERE s.date BETWEEN $1 AND $2
                       GROUP BY sm.id),
     goal_summary AS (SELECT sm.id     AS sales_manager_id,
                             sg.from_date,
                             sg.to_date,
                             sg.amount AS goal_amount
                      FROM sales_manager_goals sg
                               INNER JOIN sales_managers sm ON s.sales_manager_id = sm.id
                      WHERE sg.from_date = $1
                        AND sg.to_date = $2)
SELECT ss.sales_manager_id,
       ss.first_name,
       ss.last_name,
       ss.avatar_url,
       COALESCE(ss.total_sales_amount / NULLIF(smg.goal_amount, 0), 0) ::float AS ratio
FROM sales_summary ss
         LEFT JOIN goal_summary smg ON ss.sales_manager_id = smg.sales_manager_id
ORDER BY ratio DESC LIMIT $3
OFFSET $4
`

type GetRankedSalesManagersParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetRankedSalesManagersRow struct {
	SalesManagerID int32   `json:"sales_manager_id"`
	FirstName      string  `json:"first_name"`
	LastName       string  `json:"last_name"`
	AvatarUrl      string  `json:"avatar_url"`
	Ratio          float64 `json:"ratio"`
}

// get the ranked sales managers by their total sales divided by their sales goal amount for the given period.
func (q *Queries) GetRankedSalesManagers(ctx context.Context, arg GetRankedSalesManagersParams) ([]GetRankedSalesManagersRow, error) {
	rows, err := q.db.QueryContext(ctx, getRankedSalesManagers,
		arg.Date,
		arg.Date_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRankedSalesManagersRow
	for rows.Next() {
		var i GetRankedSalesManagersRow
		if err := rows.Scan(
			&i.SalesManagerID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.Ratio,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesByDate = `-- name: GetSalesByDate :many
SELECT id, sales_manager_id, date, amount, sale_type_id, description
from sales s
WHERE s.date = $1
`

func (q *Queries) GetSalesByDate(ctx context.Context, date time.Time) ([]Sale, error) {
	rows, err := q.db.QueryContext(ctx, getSalesByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sale
	for rows.Next() {
		var i Sale
		if err := rows.Scan(
			&i.ID,
			&i.SalesManagerID,
			&i.Date,
			&i.Amount,
			&i.SaleTypeID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesManagerSumsByType = `-- name: GetSalesManagerSumsByType :many
WITH sales_by_manager_type AS (SELECT sm.id         AS sales_manager_id,
                                      st.id         AS sale_type_id,
                                      SUM(s.amount) AS total_sales
                               FROM sales s
                                        INNER JOIN sales_managers sm ON s.sales_manager_id = sm.id
                                        INNER JOIN sale_types st ON s.sale_type_id = st.id
                               WHERE s.date BETWEEN $1 AND $2
                                 AND sm.id = $3
                               GROUP BY sm.id,
                                        st.id)
SELECT smt.sales_manager_id,
       smt.sale_type_id,
       COALESCE(smt.total_sales, 0) AS total_sales
FROM sales_by_manager_type smt
ORDER BY smt.sale_type_id ASC
`

type GetSalesManagerSumsByTypeParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	ID     int32     `json:"id"`
}

type GetSalesManagerSumsByTypeRow struct {
	SalesManagerID int32 `json:"sales_manager_id"`
	SaleTypeID     int32 `json:"sale_type_id"`
	TotalSales     int64 `json:"total_sales"`
}

// get the sales sums for a specific sales manager and each sale type within the given period.
func (q *Queries) GetSalesManagerSumsByType(ctx context.Context, arg GetSalesManagerSumsByTypeParams) ([]GetSalesManagerSumsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesManagerSumsByType, arg.Date, arg.Date_2, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesManagerSumsByTypeRow
	for rows.Next() {
		var i GetSalesManagerSumsByTypeRow
		if err := rows.Scan(&i.SalesManagerID, &i.SaleTypeID, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
